{"version":3,"file":"map-menu.umd.js","sources":["map-menu.umd.js"],"sourcesContent":["/**\n * Copyright 2018 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { html, PolymerElement } from \"@polymer/polymer/polymer-element.js\";\nimport { afterNextRender } from \"@polymer/polymer/lib/utils/render-status.js\";\nimport \"@lrnwebcomponents/smooth-scroll/smooth-scroll.js\";\nimport \"@lrnwebcomponents/map-menu/lib/map-menu-builder.js\";\n\n/**\n * `map-menu`\n * `A series of elements that generate a hierarchical menu`\n *\n * @demo demo/index.html\n */\nclass MapMenu extends PolymerElement {\n  constructor() {\n    super();\n    import(\"@lrnwebcomponents/map-menu/lib/map-menu-container.js\");\n  }\n  static get template() {\n    return html`\n      <style>\n        :host {\n          --map-menu-active-color: rgba(0, 0, 0, 0.1);\n          display: block;\n          overflow-y: scroll;\n          position: relative;\n          height: 100%;\n        }\n\n        #activeIndicator {\n          background: var(--map-menu-active-color);\n          transition: all 0.3s ease-in-out;\n          position: absolute;\n          @apply --map-menu-active-indicator;\n        }\n\n        map-menu-container {\n          padding: 32px;\n          @apply --map-menu-container;\n        }\n\n        /* turn default active color if indicator is on */\n        :host([active-indicator]) map-menu-builder {\n          --map-menu-active-color: transparent;\n        }\n      </style>\n      <div id=\"itemslist\">\n        <map-menu-container>\n          <div id=\"activeIndicator\"></div>\n          <map-menu-builder\n            id=\"builder\"\n            items=\"[[items]]\"\n            selected=\"[[selected]]\"\n          ></map-menu-builder>\n        </map-menu-container>\n      </div>\n      <smooth-scroll id=\"smoothScroll\"></smooth-scroll>\n    `;\n  }\n\n  static get tag() {\n    return \"map-menu\";\n  }\n\n  static get properties() {\n    return {\n      title: {\n        type: String,\n        value: \"Content Outline\"\n      },\n      data: {\n        type: Array,\n        value: null\n      },\n      /**\n       * Support for JSON Outline Schema manifest format\n       */\n      manifest: {\n        type: Object,\n        notify: true,\n        observer: \"_manifestChanged\"\n      },\n      items: {\n        type: Array,\n        value: null,\n        notify: true\n      },\n      /**\n       * Current selected item.\n       */\n      selected: {\n        type: String,\n        notify: true\n      },\n      /**\n       * Auto scroll an active element if not in view\n       */\n      autoScroll: {\n        type: Boolean,\n        value: false\n      },\n      /**\n       * Show active indicator animation\n       */\n      activeIndicator: {\n        type: Boolean,\n        value: false\n      }\n    };\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    afterNextRender(this, function() {\n      this.addEventListener(\n        \"link-clicked\",\n        this.__linkClickedHandler.bind(this)\n      );\n      this.addEventListener(\"toggle-updated\", this.__toggleUpdated.bind(this));\n      this.addEventListener(\"active-item\", this.__activeItemHandler.bind(this));\n      this.addEventListener(\n        \"map-meu-item-hidden-check\",\n        this._mapMeuItemHiddenCheckHandler.bind(this)\n      );\n    });\n  }\n  disconnectedCallback() {\n    this.removeEventListener(\n      \"link-clicked\",\n      this.__linkClickedHandler.bind(this)\n    );\n    this.removeEventListener(\"toggle-updated\", this.__toggleUpdated.bind(this));\n    this.removeEventListener(\n      \"active-item\",\n      this.__activeItemHandler.bind(this)\n    );\n    this.removeEventListener(\n      \"map-meu-item-hidden-check\",\n      this._mapMeuItemHiddenCheckHandler.bind(this)\n    );\n    super.disconnectedCallback();\n  }\n  static get observers() {\n    return [\"_dataChanged(data)\"];\n  }\n  __activeItemHandler(e) {\n    const target = e.detail;\n    this.refreshActiveChildren(target);\n  }\n\n  _mapMeuItemHiddenCheckHandler(e) {\n    const action = e.detail.action;\n    const target = e.detail.target;\n    const hiddenChild = e.detail.hiddenChild;\n    if (action === \"closed\" && hiddenChild === true) {\n      this.__updateActiveIndicator(this._activeItem, 200, true);\n    } else {\n      this.__updateActiveIndicator(this._activeItem, 200, false);\n    }\n  }\n\n  /**\n   * Set and unset active properties on children\n   * @param {string} activeItem\n   * @param {number} timeoutTime\n   */\n  refreshActiveChildren(activeItem, timeoutTime = 200) {\n    const oldActiveItem = this._activeItem;\n    const newActiveItem = activeItem;\n\n    if (newActiveItem && newActiveItem !== \"\") {\n      // set the new active attribute to the item\n      newActiveItem.setAttribute(\"active\", true);\n      // move the highlight thingy\n      if (this.activeIndicator) {\n        this.__updateActiveIndicator(newActiveItem, timeoutTime);\n      }\n      // if auto scroll enabled then scroll element into view\n      if (this.autoScroll) {\n        // kick off smooth scroll\n        this.$.smoothScroll.scroll(newActiveItem, {\n          duration: 300,\n          scrollElement: this\n        });\n      }\n    }\n\n    if (oldActiveItem) {\n      oldActiveItem.removeAttribute(\"active\");\n      this.__updateActiveIndicator(newActiveItem, timeoutTime);\n    }\n\n    this._activeItem = newActiveItem;\n  }\n\n  _manifestChanged(newValue, oldValue) {\n    if (newValue) {\n      this.set(\"data\", newValue.items);\n    }\n  }\n\n  /**\n   * Set data property\n   */\n  setData(data) {\n    this.set(\"data\", []);\n    this.set(\"data\", data);\n  }\n\n  /**\n   * Convert data from a linear array\n   * to a nested array for template rendering\n   */\n  _dataChanged(data) {\n    const items = [];\n    if (!data) return;\n    // find parents\n    data.forEach(element => {\n      // find top level parents\n      if (!element.parent) {\n        items.push(element);\n      }\n    });\n    // Recursively find and set children\n    items.forEach((item, i) => {\n      this._setChildren(item, data);\n    });\n    // Update items array\n    this.set(\"items\", []);\n    this.set(\"items\", items);\n  }\n\n  /**\n   * Recursively search through a data to find children\n   * of a specified item.\n   * @param {object} item item of an array to search on. Passed by reference.\n   * @param {array} data linear array of the data set.\n   * @return {void}\n   */\n  _setChildren(item, data) {\n    // find all children\n    const children = data.filter(d => item.id === d.parent);\n    item.children = children;\n    if (item.children.length > 0) {\n      item.children.forEach(child => {\n        // recursively call itself\n        this._setChildren(child, data);\n      });\n    }\n  }\n\n  /**\n   * Determine if a menu item has children\n   */\n  __hasChildren(item) {\n    return item.children.length > 0;\n  }\n\n  /**\n   * asdf\n   */\n  __linkClickedHandler(e) {\n    this.selected = e.detail.id;\n    this.dispatchEvent(\n      new CustomEvent(\"selected\", {\n        bubbles: true,\n        cancelable: true,\n        composed: true,\n        detail: e.detail.id\n      })\n    );\n  }\n\n  /**\n   * When a user clicks the toggle button to collapse or\n   * expand a submenu, this event gets triggered after\n   * the animation has been triggered\n   */\n  __toggleUpdated(e) {\n    const action = e.detail.opened ? \"opened\" : \"closed\";\n    const target = e.path[0];\n    if (typeof this._activeItem !== \"undefined\") {\n      this._activeItem.dispatchEvent(\n        new CustomEvent(\"map-menu-item-hidden-check\", {\n          bubbles: true,\n          cancelable: true,\n          composed: true,\n          detail: Object.assign(\n            {},\n            {\n              action: action,\n              target: target\n            }\n          )\n        })\n      );\n    }\n  }\n\n  /**\n   * Find out if\n   */\n  __isInViewport(element) {\n    const scrollParent = this.__getScrollParent(element);\n    if (!scrollParent) return false;\n\n    var elementTop = element.offsetTop;\n    var elementBottom = elementTop + element.offsetHeight;\n    var viewportTop = scrollParent.offsetTop;\n    var viewportBottom = viewportTop + scrollParent.offsetHeight;\n    return elementBottom > viewportTop && elementTop < viewportBottom;\n  }\n\n  /**\n   * Get scroll parent\n   */\n  __getScrollParent(node) {\n    if (node == null) {\n      return null;\n    }\n\n    if (node.scrollHeight > node.clientHeight) {\n      return node;\n    } else {\n      return this.__getScrollParent(node.parentNode);\n    }\n  }\n\n  /**\n   * Move the highlight widget over active element\n   */\n  __updateActiveIndicator(element, timeoutTime = 200, hidden = false) {\n    // run it through to set time just to let stuff set up\n    setTimeout(() => {\n      const activeIndicator = this.$.activeIndicator;\n      const left = element.offsetLeft;\n      const bottom = element.offsetBottom;\n      const top = element.offsetTop;\n      const width = element.offsetWidth;\n      // if the element is hidden the set the indicator height to zero to make it disapear\n      const height = !hidden ? element.offsetHeight : 0;\n      // if the height is zero then make the timeoutTime faster\n      timeoutTime = height > 0 ? timeoutTime : 10;\n      activeIndicator.setAttribute(\n        \"style\",\n        `width:${width}px;height:${height}px;top:${top}px;left:${left}px`\n      );\n    }, timeoutTime);\n  }\n  /**\n   * Find out if any parents of the item are collapsed\n   */\n  __parentsHidden(node) {\n    // get the parent node\n    const parent = node.parentNode;\n    // bail if we have no node to work with\n    if (parent == null) return null;\n    // if we found a submenu check if it is hidden\n    if (parent.tagName === \"MAP-MENU-SUBMENU\") {\n      // if open is set to false then we have\n      // found a hidden parent\n      if (!parent.opened) return true;\n    }\n    // wrap up and exit if we came all the way back to map-menu\n    if (parent.tagName === \"MAP-MENU\") return false;\n    // if we got all the way here then we need recursively run this\n    // against the parent node\n    return this.__parentsHidden(parent);\n  }\n}\nwindow.customElements.define(MapMenu.tag, MapMenu);\nexport { MapMenu };\n"],"names":["MapMenu","PolymerElement","html","title","type","String","value","data","Array","manifest","Object","notify","observer","items","selected","autoScroll","Boolean","activeIndicator","afterNextRender","this","addEventListener","__linkClickedHandler","bind","__toggleUpdated","__activeItemHandler","_mapMeuItemHiddenCheckHandler","removeEventListener","e","target","detail","refreshActiveChildren","action","hiddenChild","__updateActiveIndicator","_activeItem","activeItem","timeoutTime","oldActiveItem","newActiveItem","setAttribute","$","smoothScroll","scroll","duration","scrollElement","removeAttribute","newValue","oldValue","set","forEach","element","parent","push","item","i","_this2","_setChildren","children","filter","d","id","length","child","_this3","dispatchEvent","CustomEvent","bubbles","cancelable","composed","opened","path","assign","scrollParent","__getScrollParent","elementTop","offsetTop","elementBottom","offsetHeight","viewportTop","viewportBottom","node","scrollHeight","clientHeight","parentNode","hidden","setTimeout","_this4","left","offsetLeft","top","offsetBottom","width","offsetWidth","height","tagName","__parentsHidden","window","customElements","define","tag"],"mappings":"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"}